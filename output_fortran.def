include: output.def
include: macros_output/case.def
include: macros_output/for.def
include: macros_output/functions.def
include: macros_output/scope.def
include: macros_output/variables.def

include: macros/dumpout.def
include: macros/functions.def
include: macros/print.def

page: output_fortran, output_main
    output_dir: lib/MyDef
    ext: f
    package: MyDef::output_fortran


subcode: init_page
    $global $label_index
    $label_index=0

    $global $default_float = "REAL"
    $if $MyDef::def->{macros}->{use_double} or $page->{use_double}
        $default_float="DOUBLE PRECISION"

    $call function_init
    $call autolist_functions, add

fncode: get_label
    $label_index++
    return sprintf("%d", $label_index*10)

subcode: parsecode
    $call parsecode_case_support, IF, ELSEIF, fortran_style
    $if $l=~/^\$(\w+)\s*(.*?)\s*$/
        my ($func, $param)=($1, $2)
        $if $func eq "uselib"
            $global %objects
            my @tlist = split /,\s*/, $param
            $foreach $f in @tlist
                $if $f=~/^\w+$/
                    $objects{"lib$f"}=1
                $else
                    $objects{$f}=1
            return
        $elif $func eq "getlabel"
            my $s = get_label()
            $if !$param
                $param="label"
            $call set_macro, $param, $s
            return
        $elif $func eq "while"
            $if $param eq "1"
                return single_block("DO", "END DO")
            $else
                return single_block("DO WHILE ($param)", "END DO")
        $elif $func eq "for"
            $if $param =~/(\w+)\s*=(.*)/
                local_add_var("INTEGER $1")
                $if $2=~/^\s*0,/
                    $call warn, for loop start at 0? (FORTRAN often start at 1)
            return single_block("DO $param", "END DO")
        $call @parsecode_func_other
    $elif $l=~/^NOOP POST_MAIN/
        push @$out, "END"
        push @$out, "NEWLINE"
        $call function_list_all
        $call @parsecode_post
        return 0

    $call @parsecode_filter
    push @$out, $l
    return 0

# ----
subcode: case_fortran_style
    $(if:0)
        $global %op=("=="=>"EQ","<="=>"LE",">="=>"GE","<"=>"LT",">"=>"GT","/="=>"NE","!="=>"NE")
        $cond=~s/([\/!<>]=|[<>])/.$op{$1}./g
    push @src, "$case ($cond) THEN"
    $call push_indented_block
    $if $case eq "IF"
        $if !$case_wrap
            $case_wrap=[]
        push @$case_wrap, "ENDIF"

subcode: else_fortran_style
    push @src, "ELSE"
    $call push_indented_block

#----------------------------------------------- 
fncode: fortran_break_line($l)
    my $limit = 72-6
    my ($indent, $indent_size)
    $if $l=~/^(\s*)/
        $indent_size = length($1)+2
        $indent = ' ' x $indent_size

    my $limit = 72-6
    my @line_list
    my $len = length($l)
    my $i = 0
    $while $i<$len
        my $j = $i+$limit-1
        $if $indent
            $j -= $indent_size
            $call @check_j_limit

        $if $j>$len
            $j=$len
        $else
            $call get_better_break

        $if $i==0 or !$indent
            push @line_list, substr($l, $i, $j-$i)
        $else
            push @line_list, $indent.substr($l, $i, $j-$i)
        $i=$j

    return \@line_list

    # -------------------
    subcode: check_j_limit
        $if $j-$i <20
            $indent_size=2
            $indent = ' ' x $indent_size
            $j=$i+$limit -1


    subcode: get_better_break
        my $no_indent=1
        my $last_type
        $for $k=0:10
            my $type
            $(enumset:space,word,paren,break,other)
            my $c = substr($l, $j-$k, 1)
            $if $c eq ','
                $type=$(break)
            $elif $c eq ' '
                $type=$(space)
            $elif $c =~/[\(\[\{\}\]\)]/
                $type=$(paren)
            $elif $c=~/\w/
                $type=$(word)
            $else
                $type=$(other)
            $if $type==$(break) or $last_type && $type != $last_type
                $j=$j-$k+1
                $no_indent=0
                last
            $last_type = $type

        $call @check_no_indent

        subcode: check_no_indent
            $if $no_indent
                $indent_size=0
                undef $indent
