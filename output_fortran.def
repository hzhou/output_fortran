include: output.def
include: macros_output/case.def
include: macros/functions.def
include: macros/print.def

page: output_fortran, output_main
    output_dir: lib/MyDef
    ext: f
    package: MyDef::output_fortran
    autolist: 1


subcode: init_page
    $global $label_index
    $label_index=0

    $global $default_float = "REAL"
    $if $MyDef::def->{macros}->{use_double} or $page->{use_double}
        $default_float="DOUBLE PRECISION"

fncode: get_label
    $label_index++
    return sprintf("%d", $label_index*10)

subcode: parsecode
    $call parsecode_case_support, IF, ELSEIF, fortran_style
    $if $l=~/^\$(\w+)\s*(.*?)\s*$/
        my ($func, $param)=($1, $2)
        $if $func eq "uselib"
            $global %objects
            my @tlist = split /,\s*/, $param
            $foreach $f in @tlist
                $if $f=~/^\w+$/
                    $objects{"lib$f"}=1
                $else
                    $objects{$f}=1
            return
        $elif $func eq "getlabel"
            my $s = get_label()
            $if !$param
                $param="label"
            $call set_macro, $param, $s
            return
        $elif $func eq "while"
            $if $param eq "1"
                return single_block("DO", "END DO")
            $else
                return single_block("DO WHILE ($param)", "END DO")
        $elif $func eq "for"
            $if $param =~/(\w+)\s*=/
                local_add_var("INTEGER $1")
            return single_block("DO $param", "END DO")
        $call @parsecode_func_other
    $elif $l=~/^NOOP POST_MAIN/
        push @$out, "END"
        push @$out, "NEWLINE"
        $call autolist_functions, add
        $call @parsecode_post
        return 0

    $call @parsecode_filter
    push @$out, $l
    return 0

# ----
subcode: case_fortran_style
    $(if:0)
        $global %op=("=="=>"EQ","<="=>"LE",">="=>"GE","<"=>"LT",">"=>"GT","/="=>"NE","!="=>"NE")
        $cond=~s/([\/!<>]=|[<>])/.$op{$1}./g
    push @src, "$case ($cond) THEN"
    $call push_indented_block
    $if $case eq "IF"
        $if !$case_wrap
            $case_wrap=[]
        push @$case_wrap, "ENDIF"

subcode: else_fortran_style
    push @src, "ELSE"
    $call push_indented_block

#----------------------------------------------- 
subcode: dumpout
    $foreach $func in @function_list
        process_function_std($func)
    $call process_link_objects

    my @out2
    $dump->{f}=\@out2
    push @out2, "PROGRAM $page->{pagename}"
    $call declare_var_list, out2, $global_hash, @$global_list
    MyDef::dumpout::dumpout($dump)

    my $label
    $foreach $l in @out2
        $(if:1)
            chomp $l
            $call filter_f77_line
        $(else)
            push @$f, $l
    return

    subcode: filter_f77_line
        $if $l=~/^\s*LABEL\s+(\d+)/
            $label=sprintf("%5d ", $1)
        $else
            my $prefix
            $if $label
                $prefix=$label
                undef $label
            $else
                $prefix=' ' x 6

            $if length($l)>72-6
                my $line_list = fortran_break_line($l)
                $foreach $l2 in @$line_list
                    push @$f, "$prefix$l2\n"
                    $prefix = '     &'
            $else
                push @$f, "$prefix$l\n"

    subcode: process_link_objects
        my @objlist
        my @liblist
        $foreach $i in keys %objects
            $if $i=~/^lib(.*)/
                push @liblist, "-l$1"
            $else
                push @objlist, $i
        my ($lib_list, $obj_list)
        $if @liblist
            $lib_list=join(" ", @liblist)
            $page->{lib_list}=$lib_list
        $if @objlist
            $obj_list=join(" ", @objlist)
            $page->{lib_list}.=" ".$obj_list

#----------------------------------------------- 
fncode: fortran_break_line($l)
    my $limit = 72-6
    my @line_list
    my $len = length($l)
    my $i = 0
    $while $i<$len
        my $j = $i+$limit-1
        $if $j>$len
            $j=$len
        $else
            $call get_better_break
        push @line_list, substr($l, $i, $j-$i)
        $i=$j

    return \@line_list

    # -------------------
    subcode: get_better_break
        my $last_type
        $for $k=0:10
            my $type
            $(enumset:space,word,paren,other)
            my $c = substr($l, $j-$k, 1)
            $if $c eq ' '
                $type=$(space)
            $elif $c =~/[\(\[\{\}\]\)]/
                $type=$(paren)
            $elif $c=~/\w/
                $type=$(word)
            $else
                $type=$(other)
            $if $last_type && $type != $last_type
                $j=$j-$k+1
                last
            $last_type = $type
