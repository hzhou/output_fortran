include: macros_output/functions.def

subcode:: parsecode_func_other
    $case $func =~/^(return_type|parameter|lexical)$/
        $if $cur_function
            my $func=$cur_function
            $if $1 eq "return_type"
                $func->{ret_type}=$param
            $elif $1 eq "parameter"
                $call add_function_params, $cur_function
        return
    $case $func =~/^(global|local)$/
        $if $1 eq "global"
            global_add_var($param)
        $else
            local_add_var($param)
        return

#----------------------------------------------- 
fncode: local_add_var($param)
    $if $cur_function
        add_variable($cur_function->{var_hash}, $cur_function->{var_list}, $param)
    $else
        add_variable($global_hash, $global_list, $param)

fncode: global_add_var($param)
    $global $global_hash={}, $global_list=[]
    add_variable($global_hash, $global_list, $param)

fncode: add_variable($var_hash, $var_list, $param)
    my @plist=split /,\s*/, $param
    $foreach $p in @plist
        my ($type, $name, $dim, $val)
        $if $p=~/^(.*?(\w+))\s*=\s*(.+)/
            ($p, $name, $val) = ($1, $2, $3)
            push @$out, "$name = $val"
            $if $val =~/^'(.*)'$/
                $type="CHARACTER"
                $dim =length($1)
            $elif $val =~/^\.(true|false).$/i
                $type="LOGICAL"
        $if !$type
            ($type, $name, $dim)=parse_var($p)
        $if !$var_hash->{$name}
            $var_hash->{$name}={name=>$name, type=>$type, dim=>$dim}
            push @$var_list, $name

#----------------------------------------------- 
macros:
    function_style: fortran

subcode: function_param_fortran
    my ($type, $name, $dim)=parse_var($p)
    $var_hash->{$name}={name=>$name, type=>$type, dim=>$dim}
    push @$param_list, $name

fncode: parse_var($p)
    my ($type, $name, $dim)
    $if $p=~/(\S.*)\s+(\S+)\s*$/
        ($type, $name)=($1, $2)
    $else
        $name=$p
        $if $p=~/^f/i
            $type=$default_float
        $elif $p=~/^d/i
            $type="DOUBLE PRECISION"
        $elif $p=~/^s/i
            $type="CHARACTER"
        $elif $p=~/^[ijklmn]/i
            $type="INTEGER"
        $else
            $type=$default_float

    $if $name=~/(\w+)\((.*)\)/
        $name=$1
        $dim =$2
    return ($type, $name, $dim)

subcode: function_open_fortran
    my $ret_type = $func->{ret_type}
    my $param_list = $func->{param_list}
    my $param = join(', ', @$param_list)
    $if !$ret_type
        push @$open, "SUBROUTINE $name($param)"
    $else
        push @$open, "$ret_type FUNCTION $name($param)"

subcode: function_close_fortran
    push @$close, "END"
    push @$close, "NEWLINE"

subcode: infer_return_fortran
# ----------------------------
subcode: declare_var_list(out, hash, @list)
    my %type_list
    $foreach $p in $(list)
        my $type=$(hash)->{$p}->{type}
        my $dim=$(hash)->{$p}->{dim}
        my $name=$p
        $if $dim
            $if $type eq "CHARACTER"
                $name.="*$dim"
            $else
                $name.="($dim)"

        $if !$type_list{$type}
            $type_list{$type}=[]
        push @{$type_list{$type}}, $name


    $foreach %type_list
        push @$(out), "$k ".join(", ", @$v)


