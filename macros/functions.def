include: macros_output/functions.def

subcode: autolist_functions
    &call each_subcode, fn
        $call list_function, $name

subcode: function_pop
    # necessary wrap "end if" at end of code
    $call case_reset

subcode:: parsecode_func_other
    $case $func =~/^(return_type|parameter|lexical)$/
        $if $cur_function
            my $func=$cur_function
            $if $1 eq "return_type"
                $func->{ret_type}=$param
            $elif $1 eq "parameter"
                $call add_function_parameter
        return
    $case $func =~/^(global|local)$/
        $if $1 eq "global"
            global_add_var($param)
        $else
            local_add_var($param)
        return

#----------------------------------------------- 
fncode: local_add_var($param)
    $if $cur_function
        add_variable($cur_function->{var_hash}, $cur_function->{var_list}, $param)
    $else
        add_variable($global_hash, $global_list, $param)

fncode: global_add_var($param)
    $global $global_hash={}, $global_list=[]
    add_variable($global_hash, $global_list, $param)

fncode: add_variable($var_hash, $var_list, $param)
    my @plist=split /,\s*/, $param
    $foreach $p in @plist
        my ($type, $name, $dim, $val)
        $if $p=~/^(.*?(\w+))\s*=\s*(.+)/
            ($p, $name, $val) = ($1, $2, $3)
            push @$out, "$name = $val"
            $if $val =~/^'(.*)'$/
                $type="CHARACTER"
                $dim =length($1)
            $elif $val =~/^\.(true|false).$/i
                $type="LOGICAL"
        $if !$type
            ($type, $name, $dim)=parse_var($p)
        $if !$var_hash->{$name}
            $var_hash->{$name}={name=>$name, type=>$type, dim=>$dim}
            push @$var_list, $name

#----------------------------------------------- 
fncode: open_function($name, $param)
    my $func={param_list=>[], var_list=>[], var_hash=>{}, init=>[], finish=>[]}
    $func->{name}=$name

    $global $cur_function
    $cur_function=$func

    $if $param
        $call add_function_parameter

    return $func


subcode: add_function_parameter
    my $param_list = $func->{param_list}
    my $var_hash = $func->{var_hash}
    my @plist = split /,\s*/, $param

    $foreach $p in @plist
        my ($type, $name, $dim)=parse_var($p)
        $var_hash->{$name}={name=>$name, type=>$type, dim=>$dim}
        push @$param_list, $name

fncode: parse_var($p)
    my ($type, $name, $dim)
    $if $p=~/(\S.*)\s+(\S+)\s*$/
        ($type, $name)=($1, $2)
    $else
        $name=$p
        $if $p=~/^f/i
            $type=$default_float
        $elif $p=~/^d/i
            $type="DOUBLE PRECISION"
        $elif $p=~/^s/i
            $type="CHARACTER"
        $elif $p=~/^[ijklmn]/i
            $type="INTEGER"
        $else
            $type=$default_float

    $if $name=~/(\w+)\((.*)\)/
        $name=$1
        $dim =$2
    return ($type, $name, $dim)


fncode: process_function($func)
    my $name=$func->{name}
    $(for:open in open,pre,post,close)
        my $$(open) = $func->{$(open)block}

    my $ret_type = $func->{ret_type}
    my $param_list = $func->{param_list}
    my $param = join(', ', @$param_list)
    $if !$ret_type
        push @$open, "SUBROUTINE $name($param)"
    $else
        push @$open, "$ret_type FUNCTION $name($param)"

    # -------
    my $var_hash=$func->{var_hash}
    my $var_list=$func->{var_list}
    $call declare_var_list, $pre, $var_hash, @$param_list, @$var_list

    # -------
    push @$close, "END"
    push @$close, "NEWLINE"

subcode: declare_var_list(out, hash, @list)
    my %type_list
    $foreach $p in $(list)
        my $type=$(hash)->{$p}->{type}
        my $dim=$(hash)->{$p}->{dim}
        my $name=$p
        $if $dim
            $if $type eq "CHARACTER"
                $name.="*$dim"
            $else
                $name.="($dim)"

        $if !$type_list{$type}
            $type_list{$type}=[]
        push @{$type_list{$type}}, $name


    $foreach %type_list
        push @$(out), "$k ".join(", ", @$v)


